#  Java笔记

JVM(Java Virtula Machine) 	java虚拟机

JDK(Java Development Kit)	java开发工具包

JRE(Java Runtime Environment)	java运行环境

## 一、java的基本程序设计结构：

### 命名规范

- 类名是以大写字母开头的名词，如果名字由多个单词组成，每个单词的第一个字母应该大写，遵循驼峰命名法。
- 源代码的文件名必须与公共类的名字相同，并用.java作为拓展名。

### 多个源文件的使用

- 如有两个源文件：Employee.java和EmployeeTest.java。对于这两个源文件，有两种编译方法：
- 一、javac Employee*.java 这样一来，所有与通配符匹配的源文件都将被编译成源文件。
- 二、或javac EmployeeTest.java 这种方式虽然没有显式地编译Employee.java，但是当java编译器发现EmployeeTest.java使用了Employee类时，他会查找名为Employee.class的文件。如果没有找到这个文件，就会自动搜索Emplyoee.java，然后对他进行编译。如果Emplyoee.java版本较Employee.class文件版本更新，java编译器就会自动重新编译这个文件。

### 注意

- main方法必须声明为public。
- 每个java应用程序都必须有一个main方法。java中的所有函数都是某个类的方法。
- 在一个源文件中，只能有一个公共类，但可以有任意多数目的非公共类。

## 二、数据类型：

### java中的数据类型

- java是一种强类型语言(对比javascript为一种弱类型语言)，必须为每一个变量声明一种类型。其中有4种整型：int，short，long，byte，2种浮点类型：float，double，一种字符类型：char。布尔类型：boolean。

- 整型： 

  在java中，整型的范围与运行java代码的机器无关。  
  int(4字节)，short(2字节)，long(8字节)，byte(1字节)

  长整型数值有一个后缀L或l，十六进制数值有一个前缀0x或0X，八进制有一个前缀0。

  从java7开始，加上前缀0b或者0B就可以写二进制数，如0b1001。

  从java7开始，还可以为数字字面量加下划线，如1_000_000表示一百万，java编译器会自动去除这些下划线。

- 浮点型：

  float(4字节)，double(8字节)

  float类型有一个后缀F或f，没有后缀F的浮点值默认为double类型，可在浮点值后面添加后缀D或d表示double类型。

  Double.POSITIVE_INFINITY正无穷

  Double.NAGATIVE_INFINITY负无穷

  Double.NAN不是一个数字

- 注意：boolean类型0!=false

- var关键字：

  在java10开始，对于局部变量，如果可以从变量的从初始值判断出他的类型，就不再需要声明类型，使用var关键字无需指定类型。

- final关键字：

  关键字final表示这个变量只能被赋值一次，一旦被赋值后就不能被更改了。

  可以使用static final设置一个类常量，类常量的定义位于main方法的外部，在同一个类的其他方法中也可以使用这个常量。如果一个常量被声明为public，那么在其他类的方法中也可以使用这个常量。

- 枚举类型enum：

  ```
  自定义枚举类型：
  enum Size = {SMALL,MEDIUM,LARGE,EXTRA_LARGE}
  现在，可以声明这种类型的变量：
  Size s = Size.MEDIUM;
  Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。
  ```

- 字符串String类型：

  ```
  equals方法检测两个字符串是否相等(区分大小写)：
  如"hello".equals(greeting);
  equalsIgnoreCase不区分大小写：
  "Hello".equalsIgnoreCase('SF');
  注意：一定不要使用!=或==运算符来检测两个String变量是否相等，这个运算符只能确定两个字符串是否放在同一个位置上。
  
  可以使用静态的String.format方法创建一个格式化的字符串
  如String message = String.format("Hello,%s,next year,you'll be %d",name,age);
  
  构建字符串(StringBuilder)：
  有些时候，需要由许多较短的字符串构建字符串。使用StringBuilder类实例一个对象，然后将String数据append进这个对象内，最后调用这个对象的toString方法转化成字符串类型。
  ```

- 数组：

  ​		初始化一个可以存储100个整型数据的数组：

  ​		int[] a = new int[100];

  ​		创建一个长度为0的数组：

  ​		new elementType[0];	或new elementType[ ] { };

  ​		数组拷贝：

  ​		使用Arrays类的copyOf方法，第一个参数为数组名，第二个参数为新的数组长度，这个方法通常用来增加数组的大小。如果数组元素是数值型，那么额外的元素将被赋值为0。如果数组元素是布尔型，则将赋值为false。如果长度小于原始数组的长度，则只拷贝前面的值。

  ​		如：CopyLuckyNumbers = Arrays.copyOf(luckyNumbers,2*luckyNumbers.lengths);

   

  在java中，多维数组可以解释为：如二维数组其一维数组存放着第二维数组的地址，第二维数组存放数据(该行的数据)。

- Math类：

  ​       不必在数学方法名和常量名前缀加"Math"，只要在源文件的顶部引入下面这行代码即可：

  ​		import static java.lang.Math.*;

  ```
  Math.sqrt()求平方根
  Math.pow()求幂
  三角函数：
  Math.sin	Math.cos	Math.tan
  Math.atan	Math.atan2
  指数函数以及他的反函数，自然对数以及以10为底的对数：
  Math.exp	Math.log	Math.log10
  自然数pi和e：
  Math.PI		Math.E
  
  对浮点数做四舍五入计算：
  Math.round()，结果返回一个long类型。
  
  大数：
  BigInteger和BigDecimal，这两个类可以处理包含任意长度数字序列的数值。
  使用静态的valueOf()方法可以将普通的数值转化为大数：
  BigInteger a = BigInteger.valueOf(100);
  对于更大的数，可以使用一个带字符串参数的构造器：
  BigInteger big = new BigInteger("234444444444444444444443456346234625324546244334523454376453672623235242343242423");
  处理大数，需要使用add和multiply，subtract，divide，mode等方法。
  ```

## 三、输入与输出：

### 读取输入

- 想要用户从控制台进行输入，首页需要构造一个"标准输入流"System.in关联的Scanner对象。

- 注意：Scanner类定义在java.util包中。当使用的类不是java.lang基本包中时，一定要使用import指令导入相应的包。

  ```
  Scanner in = new Scanner(System.in);
  nextLine方法将读取一行输入，next方法将读取一个单词输入，nextInt将读取一个整数的输入，nextDouble方法将读取一个浮点型输入。
  如String name = in.nextLine();
  
  boolean hasNext()检测输入中是否还有其他单词。
  boolen hasNextInt();
  boolen hasNextDouble();
  ```

### 打印输出

- System.out.print();     打印字符串或数据，printLn换行
- System.out.printf();    类似C语言的格式化输出

### 文件的输入与输出

- 读取文件，先构造一个Scanner对象。

  Scanner in = new Scanner(Path.of("myfile.txt"),StandardCharsets.UTF_8);

- 写入文件，先构造一个PrintWriter对象。

  PrintWriter out = new PrintWriter("myfile.txt",StandardCharsets.UTF_8););

## 四、对象与类(面向对象)：

### 对象的三个主要特性

- 对象的行为：可以对对象完成的一些操作。
- 对象的状态：当调用那些方法时，对象会如何相应。
- 对象的标识：区分具有相同行为与状态的不同对象。
- 对象状态的改变必须通过调用方法实现，否则说明破坏了封装性。

### 类之间的关系

- 依赖：如果一个类的方法使用或操纵另一个类的对象，就说一个类依赖于另一个类。
  - 应该尽可能的减少类的相互依赖，也就是说尽可能减少类之间的耦合。
- 聚合：如一个对象包含另一个对象。
- 继承：如类A扩展类B，类A不但包含从类B继承的方法，还有一些额外的功能。

### 对象变量

- 对象变量并没有实际包含一个对象，他只是引用一个对象，new操作符的返回值也是一个引用。

### 自定义类

- ```
  class Employee
  {
  	//instance filed
  	//实例字段，由于public数据字段允许程序中的任何方法对其进行修改和读取，所以建议使用关键字private非public标记，保护封装。
  	private String name;
  	private double salary;
  	private LocalDate hireDay;
  	
  	//constructor构造器
  	//构造器与类同名，在构造Employee类的对象时，构造器会运行。有0或1或多个参数。
  	//每个类可以有多个构造器，构造器没有返回值，总是与new关键字一起调用。 
  	public Employee(String n, double s, int year, int month, int day){
  		name = n;
  		salary = n;
  		hireDay = LocalDate.of(year, month, date );
  	}
  	
  	//a method
  	public String getName(){
  		return name;
  	}
  	
  	//method
  	public Date getHireDay(){
  		return (Date)hiredDay.clone();
  		//如果需要返回一个可变对象的引用，首先应该对他进行克隆(对象克隆指存放在另一个新位置上的对象副本)。
  		//如果不使用克隆后的对象返回，若使用一个字段接收直接返回的值，则该字段与hireDay引用同一个对象。
  	}
  	
  	//method
  	public void raiseSalary(double byPercent){
  		double raise = salary * byPercent / 100;
  		salary += raise;
  	}
  }
  ```

- Employee类的方法可以访问任何Employee类型对象的私有字段。

### 隐式参数与显式参数

- Emplyoee类的raiseSalary方法中有两个参数，第一个参数为隐式参数，是指出现在方法名前的Employee类型的对象。在每个方法中，关键字this指示隐式参数。

- 第二个参数是位于方法名后面括号中的数值，如byPercent，为显式参数。

- ```
  使用this关键字改写raiseSalary方法：
  public void raiseSalary(double byPercent){
  		double raise = this.salary * byPercent / 100;
  		this.salary += raise;
  	}
  ```

### final实例字段

- 可以将实例字段定义为final，这样的字段必须在构造对象时初始化，并且以后不能再修改这个字段的值。
  - 对于可变的类，如private final StringBuilder evaluations;	evaluations = new StringBuilder();
  - final关键字只是表示存储在evaluations变量中的对象引用不会再改变，不过这个对象可更改：
  - evaluations.append(LocalDate.now() += ": Gold star!\n" );

### 静态字段与静态方法

- 关键字static：指示属于类而不属于任何类对象的变量和函数。

- 静态字段：如果将一个字段定义为static，每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。

- 如，给Employee类添加一个实例字段id和一个静态字段nextId:

- ```
  class Employee
  {
  	private static int nextId = 1;
  	private int id;
  }
  ```

- 现在每一个Employee对象都有一个自己的id字段，但这个类的所有实例将共享一个nextId字段。即使没有Employee对象，静态字段nextId也存在，而不属于任何单个对象。

  

- 静态方法：静态方法不是在对象上执行的方法。可认为静态方法是没有this参数的方法。

- Employee的静态方法不能访问id实例字段，因为他不能在对象上操作。但是，静态方法可以访问静态字段。

- 以下两种情况可以使用静态方法：

  - 方法不需要访问对象状态，因为他需要的参数都通过显式参数提供。
  - 方法只需要访问类的静态字段。

- 可以调用静态方法而不需要任何对象。例如，不需要Math类的任何对象就可以调用Math.pow

- main函数也是一个静态方法。

### 方法参数

- java语言的方法得到的所有参数值是该参数值的一个**副本**，即**按值调用**，而不是按引用调用。
- 具体来讲，方法不能修改传递给他的任何参数变量的内容。一个方法不能修改基本数据类型的参数。
- 但是，方法却可以修改对象的参数状态，因为方法传参后得到的是对象引用的副本，原来的对象引用和这个副本都引用同一个对象，只是无法修改原来对象的引用。

### 重载

- 如果多个方法，有相同的名字，不同的参数，便出现了重载，编译器必须挑选出具体调用哪个方法。

- 要完整地描述一个方法，必须指定方法名和参数类型，这叫做方法的签名。

- ```
  如String类有4个名为indexOf的公共方法，他们的签名是
  indexOf(int)
  indexOf(int, int)
  indexOf(String)
  indexOf(String, int)
  ```

- 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同，参数类型也相同却有不同放回类型的方法。

### 调用另一个构造器

- 如果构造器第一个语句如this(...)，这个构造器将调用同一个类的另一个构造器。

- ```
  public Employee(double s){
  	//call Employee(String, double)
  	this('Employee #' + nextId, s);
  	nextId++;
  }
  ```

### 初始化块

- 除了以下两种初始化数据字段的方法：一、在构造器中设置值。二、在声明中赋值。java还有第三种机制，称为初始化块。在一个类的声明种，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。

- ```
  class Employee
  {
  	private static int nextId;
  	
  	private int id;
  	private String name;
  	private double salary;
  	
  	//object initialization block
  	{
  		id = nextId;
  		nextId++;
  	}
  	
  	public Employee(String n, double s)
  	{
  		name = n;
  		salary = s;
  	}
  	
  	public Employee()
  	{
  		name = '';
  		salary = 0;
  	}
  }
  ```

- ```
  //如果类的静态字段需要很复杂的初始化代码，那么可以使用静态的初始化块
  //static initialization block
  static
  {
  	var generator = new Randow();
  	nextId = generator.nextInt(1000);
  }
  ```


### JAR文件

- 在将应用程序打包时，java归档(JAR)文件向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构。
- 一个JAR文件既可以是包含类的文件，也可以包含诸如图像和声音等其他类型的文件。
- JAR文件是压缩的，他使用了ZIP压缩格式。

### 类设计技巧

1. 一定要保证数据私有

2. 一定要对数据进行初始化

3. 不要在类中过多的使用基本类型

   ```
   //这个想法是要用其他的类替换使用多个相关的基本类型。这样会使类更易于理解与修改。
   //例如，使用一个Address的新类替换一个Customer类中的以下实例字段：
   private String street;
   private String city;
   private String state;
   private int zip;
   ```

4. 不是所有字段都需要单独的字段访问器和字段更改器

5. 分解有过多指责的类

6. 类名和方法名要能够体现他们的职责

   类名应该是一个名词，或者是前面有形容词修饰的名词，或者是有动名词(-ing)修饰的名词。

   对于方法，访问器方法用小写get开头(getSalary)，更改器用小写的set开头(setSalary)。

7. 优化使用不可变的类

## 五、继承：

### 类、超类、子类

-  Object类是java中所有类的超类(始祖)，可以使用Object类型的变量引用任何类型的对象。

- 可以如下继承Employee类来定义Manager类，使用关键字extends表示继承 

   public class Manager extends Employee

- 超类中的有些方法对子类来说并不一定适用，可以提供一个新方法来**覆盖**超类中的这个方法。

- super关键字指示编译器调用超类方法的特殊关键字。不能将super赋值给另一个对象变量。

  如以下代码中，子类中覆盖了getSalary方法，获取Manager类的salary后加上bonus

  ```
  public double getSalary()
  {
  	double baseSalary = super.getSalary();
  	return baseSalary + bonus;
  }
  /** 如果不加super关键字，他只是在调用自身getSalary，因为Manager类也有一个getSalary方法。所以这条不加super的语句将无限次调用自身，导致程序崩溃。
  */
  ```

- 子类构造器

  ```
  public Manager(String name, double salary, int year, int month, int day)
  {
  	super(name, salary, year, month, day);
  	bonus = 0;
  }
  /** 语句super(name, salary, year, month, day);是调用超类Employee中带有n,s,year,month,day参数的构造器的简写形式。
  	由于Manager类的构造器不能访问Employee类的私有字段，所以必须通过一个构造器来初始化这些私有字段。
  	super调用构造器的语句必须是子类构造器的第一条语句。
  	如果子类的构造器没有显式地调用超类的构造器，将自动调用超类的无参构造器。
  	如果超类没有无参构造器，并且子类的构造器中又没有显式地调用超类的其他构造器，java编译器就会报错。
  */
  ```

- 

### 多态

- 一个对象变量可以只是多种实际类型的现象成为**多态**。在运行时能够自动选择适当的方法，称为**动态绑定**。
- 如果是private方法，static方法，final方法或者构造器，那么编译器将可以准确的知道应该调用哪个方法，这称为**静态绑定**。如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用**动态绑定**。
- 子类的每个对象也是超类的对象。可以将子类对象赋值给超类变量。

### 阻止继承：final类和方法

- 阻止某个类定义子类，不允许拓展的类称为final类。

  如:	public **final** class Executive extends Manager

- 类中的某个特定方法也可以被声明为final，子类就不能覆盖这个方法。  

### 强制类型转换

- java类也能进行强制类型转换，但只能在**继承层次**内进行强制类型转换。
- 在对类进行强制类型转换之前，应该使用关键字**instanceof**进行检查，成功才进行转换。
- 一般情况之下，最好少用类的强制类型转换。若出于某种愿意发现需要在超类的对象上调用子类的对象上的方法，那么应该自问超类的设计是否合理。 

### 抽象类

- 在继承层级的上层的类更具有一般性，可以更加抽象，用来作为派生其他类的基类。

- 如每个人都有姓名这一属性，学生和员工都有姓名这一属性。便可以将这个属性放入公共的超类中。如有一获取一个人描述的方法getDescription，可以放在超类中，使用**abstract**关键字，就在超类中完全不需要实现这个方法了。他们在子类中具体实现。

- 为了提高程序的清晰度，包含一个或者多个抽象方法的类本身必须被声明为抽象的。

  ```
  //如下:
  public abstract class Person
  {
  	public abstract String getDescription();
  }
  ```

- 扩展抽象类有两种选择，一是在子类中保留抽象类中的部分或全部抽象方法仍定义，这样就必须将子类也标记为抽象类。另一种做法是定义全部方法，这样一来子类就不是抽象类了。

- 即使不含抽象方法，也可以将类声明为抽象类。

- 抽象类不能实例化。可以定义一个抽象类的对象变量，但是这个对象变量只能引用非抽象之类的对象。

-  

  ```
  //Person为超类，Employee与Student为子类
  var people = new Person[2];
  people[0] = new Employee(...);
  people[1] = new Student(...);
  
  for(Person p : people)
  {
  	System.out.printLn(p.getName() + "," + p.getDescription());
  }
  /**	由于不能构造抽象类Person的对象，所以变量P永远不会引用Person对象，而是引用Employee或Student		这样的具体子类的对象，而这些对象中都定义了getDescription方法。
  	抽象方法的好处:	
  	如果省略抽象Person超类中的抽象方法，而仅在Employee和Student子类中定义getDeescription方法。	   那么就不能在变量P中调用getDescripiton方法了。
  */
  ```

### 受访问保护

- 希望限制超类中的某个方法只允许之类访问，或是希望允许子类的方法访问超类的某个字段。
- 在java中，保护字段**protected**只能由同一个包中的类访问，以及所有子类访问。

### Object类的方法

- equals:	检测一个对象是否等于另一个对象(对象的引用是否相等)。

- hashCode: &emsp;散列码(hashCode)由对象导出的一个整型值，没有规律。每个对象都有一个默认的散列码，Object类的默认hashCode方法其值由对象的存储地址给出(而String类给出的散列码为内容导出)。

- hash: &emsp;需要组合多个散列值时，可以调用Object.hash并提供这些参数。这个方法会对各个参数对用hashCode方法，并组合这些散列值。

  ​	如果存在数组类型的字段，可以使用静态的Array.hashCode方法得到一个由数组元素的散列码组成的散列码。

- toString:&emsp;返回表示对象值的一个字符串。绝大多数的toString方法都遵循这样的格式：

  ​	类的名字，随后是一对方括号括起来的字段值。

  ​	如：Employee[name = 'sf', salary = '100']

  ​	只要一个对象与一个字符串通过操作符 "+" 连接起来，java编译器就会自动调用toString方法来获得这个对象的字符串描述。

  ​	如果想要打印多维数组，可以使用Arrays.deepToString方法。

### 泛型数组列表

- 在java中，允许在运行时确定数组的大小，如int actualSize = ...;	var staff = new Employee[actualSize];

- 一旦确定了数组大小，就不能容易改变他了。可以使用ArrayList类来解决，ArrayList类类似数组，但在添加或删除元素时，他能够自动调整数组容量。ArrayList是一个有类型参数的泛型类，为了指定数组列表保存的元素对象的类型，需要用一对尖括号将类名括起来追加到ArrayList后面，如ArrayList<Employee>;

- 菱形语法：如 ArrayList<Employee> staff = new ArrayList<Employee>();

  使用菱形语法写成： ArrayList<Employee> staff = new ArrayList<>(); 省略了右边的参数。

  如果使用var声明ArrayList，就不要使用菱形语法省略参数，会生成一个ArrayList<Object>

- 使用add方法可以将元素添加到数组列表中，可以指定添加的位置。如果已经知道或能估计出数组可能的大小，就可以在填充数组之前调用ensureCapacity方法：staff.ensureCapacity(100); 这样一来，前100次add调用不会带来开销很大的重新分配空间。此外，还可以把初始容量传递给ArrayList构造器：ArrayList<Employee> staff = new ArrayList<>(100);

- size方法将返回数组列表中返回的实际元素个数。使用remove方法删除列表中的一个元素。

- 一旦确定数组列表的大小将保持恒定不变，就可以调用trimToSize方法，这个方法将存储块的大小调整为保持当前元素数量所需要的存储空间，垃圾回收器将回收多余的空间。

- 访问数组列表元素：使用get和set方法，如要替换下标为i的元素：staff.set(i, harry); 要得到下标为i的元素: staff.get(i);

### 对象包装器与自动装箱

- 将int等基本类型转换为对象，所有的基本类型都有一个与之对应的类。
- Integer类对应的基本类型就是int，这些类称为包装器。有Integer, Long, Float, Double, Short, Byte, Character, Boolean(前六个类派生与公共超类Number)。
- 包装器类是不可变的，因此一旦构造了包装器，就不允许更改包装器在其中的值。
- 包装器类还是final，因此不能派生他的子类。
- 泛型数组列表的尖括号中的类型参数不允许是基本类型，如定义一个整数类型数组列表。所以需要用到Integer包装器类。
- ArrayList有一特性：只需向ArrayList添加int类型元素，如list.add(3)就会自动变成list.add(Integer.valueOf(3));这一变换称为**自动装箱**。
- 将一个Integer对象赋值给一个int变量时，将会**自动拆箱**。如int n = list.get(i);会自动转换成int n = list.get(i).intValue();

### 枚举类

- 定义枚举类型public enum Size{ SMALL, MEDIUM, LARGE, EXTRA_LARGE }
- 枚举的构造器是私有的，可以省略private修饰符。但如果声明一个enmu构造器为public或protected，会报错。
- toString返回枚举参量名，如Size.SMALL.toString();
- 每个枚举类型都有一个values方法，返回一个包含全部枚举值的数组，如Size.values();

## 六、接口，lambda表达式与内部类：

### 接口(interface)

- java不支持多重继承(从多个类中派生出一个子类)，有了接口，就可以实现多重继承的方法。有时候必须从几个类中抽取出一些公共的行为特征，而他们之间又没有is-a关系，仅仅是有相同的行为特征而已。

- 接口就是规范，定义的是一组规则/标准/契约。

- 接口使用Interface来定义，接口中不能定义构造器。Java开发中，接口通过类去实现(implments)的方式来使用，如果实现类覆盖了接口中所有的抽象方法，则此实现类就可以实例化，如果实现类没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类，不能被实例化。

- 接口与接口之间可以继承，而且可以多重继承，格式： class AA extends BB implements CC,DD,EE

- 接口不能提供实例字段。接口中的所有方法默认是public方法，可以省略关键字public，但在实现接口时，必须把方法声明为public。

- 接口不是类，不能使用new运算符实例化一个接口。却能够声明一个接口变量，这个接口变量必须引用实现了这个接口的类对象。

- 在接口中虽然不能包含实例字段，却可以包含常量，如double SPEED_LIMIT = 95; 接口中的字段总是被自动设置为public static final。

- **接口的默认方法：**可以为接口的方法提供一个默认实现，必须用**default**修饰符标记这个方法。

- 解决默认方法冲突：如果一个接口中将一个方法定义为默认方法，然后又在超类中或另一个接口中定义同样的方法，那么规则如下：

  超类优先，如果超类提供了一个具体方法，同名且具有相同参数类型的默认方法会被忽略。

  如果一个接口提供了默认方法，另一个接口提供了一个同名并且参数类型相同的方法，那么必需覆盖这个方法来解决冲突。 

- **接口的静态方法：**接口中的静态方法不能被子接口继承，静态方法不能被实现该接口的实现类继承。

  使用该静态方法只能通过：接口名称.静态方法名

- **接口私有方法：**接口中出现私有方法的目的就是解决多个默认方法之间的重复代码问题。

  普通私有方法是解决多个默认方法之间重复代码的问题；private void method();

  静态私有方法是解决多个静态方法之间的代码重复问题。 private static void method();

### lambda表达式

- lambda表达式形式：参数，箭头(->)以及一个表达式。
- 即使lambda表达式没有参数，仍要提供空括号。
- 如果参数的类型可以由推导得出，那么可以忽略其类型。
- 如果方法只有一个参数，而且这个参数的类型可以右推导得出，甚至可以省略小括号。
- 无需指定lambda表达式的返回类型，lambda表达式的返回类型总是可以由上下文推导得出。

### 内部类

- 内用外，随意访问。外用内，需要内部类对象。

- 使用内部类的方法：一、在外部类的方法中，使用内部类。 二、外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();   如Body.Heart heart = new Body().new Heart(); (Body为外部类，Heart为内部类)。

- 如果出现内部类的同名变量访问问题，使用如下格式来访问：外部类名称.this.外部类成员变量名 

- **局部内部类：**如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

  局部内部类不能写权限修饰符。

  如果希望访问所在方法的局部变量，那么这个局部变量必须是有效的(final)。从java8+开始，只要局部变量的值不变，那么final关键字可以省略。

- **匿名内部类：**如果接口的实现类只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用[匿名内部类]。 匿名内部类的定义格式： 接口名称 对象名 = new 接口名称(){ //覆盖重写所有抽象方法  }

## 七、异常，断言和日志：

### 异常

- 异常指的是程序在执行过程中，出现的非正常情况，导致JVM的非正常停止。

- 在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出。java处理异常的方式就是中断处理。

- 异常机制帮助我们找到程序中的问题。异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平时所说是异常指java.lang.Exception。

- **Exception：**编译期异常，RuntimeExcepiton：运行期异常。

- **Error：**错误，必须修改源代码，程序才能重新执行。 

- 异常的产生过程：jvm检测出异常，会根据异常产生的原因创建一个异常对象，这个异常对象包含了异常产生的(内容，原因，位置)。在某个方法中，没有异常的处理逻辑(try...catch)，那么jvm就会被异常对象抛出给这个方法的调用者，如main方法。若main方法接收到了这个对象，却也没有异常的处理逻辑，那么main方法继续把异常对象抛出给main方法的调用者，如jvm处理。jvm接收到了这个异常对象，做了两件事情：把异常对象(内容，原因，位置)以红色字体打印在控制台。jvm会终止当前正常执行的java程序(中断处理)。

- **throw：**可以使用throw关键字在指定的方法中抛出指定的异常。格式：throw new xxxEception("异常产生的原因");   注意：throw关键字必须写在方法内部。throw关键字后边new的对象必须是Exception或者Exception的子类对象。throw关键字抛出指定的异常对象，我们就必须处理这个异常对象(throw关键字后边创建的是RuntimeException或者是RuntimeExcepiton的子类对象，我们可以不处理，默认交给JVM处理。若throw后边创建的是编译异常，我们就必须处理这个异常)。

- **throws：**当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象。可以使用**throw**s关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理(自己不用处理，给别人处理)，最终交给JVM处理。

  在方法声明时使用，格式：修饰符 返回值类型 方法名(参数列表) throws XXXException, BBBException...{

  ​	throw new XXXException("产生原因");   throw new BBBException("产生原因");

  }

  throws关键字后声明的异常必须是Exception或者是Exception的子类。方法内部如果抛出多个异常对象，那么throws后边必须也声明多个异常。如果抛出的多个异常对象有子父类关系，那么之间声明父类异常即可。

- **finally：**无论是否出现异常都会执行。finally不能单独使用，必须与try一起使用。finally一般用于资源释放(资源回收)，无论程序是否出现异常，最后都要资源释放。

## 八、泛型程序设计：

## 九、集合：

### 集合框架

- **Collection<E>**是单列集合类的根接口，用于存储一系列符合某种规则的元素，他有两个重要的子接口，分别是java.util.List和java.util.Set。

- List的特点是元素有序，元素可重复。List接口的实现类有ArrayList，LinkedList，Vector

- set的特点是元素无序，而且不可重复。Set接口的实现类有HashSet，TreeSet，LinkedHashSet

- Collection中的常用功能(List和Set的通用方法)，这些方法可以用于操作单列集合。

  ```
  //共性的方法：
  public boolean add(E e); //把给定对象添加到当前集合中
  public void clear(); //清空集合中的所有元素
  public boolean remove(E e); //把给定的对象在当前集合中删除
  public boolean contains(E e); //判断当前集合中是否包含指定对象
  public boolean isEmpty(); //判断当前集合是否为空
  public int size(); //返回集合中的元素个数
  public Object[] toArray(); //把集合中的元素存储到数组中
  ```

### Iterator(迭代器)接口

- Iterator主要用于迭代访问(遍历)Collection中的元素。

- Iterator的常用方法： public E next();返回迭代的下一个元素。 

  ​		public boolean hasNext();如果仍有元素可以迭代，则返回true。

- Collection接口中有一个方法，较iterator(),这个方法返回的就是迭代器的实现类对象。

- 迭代器的使用步骤：1.使用集合中的方法iterator()获取迭代器的实现类对象，使用iterator接口接收(多态)。     

  2.使用Iterator接口中的方法hasNext判断还有没有下一个元素。

  3.使用Iterator接口中的方法next取出集合中的下一个元素。

- 迭代器的实现原理：获取迭代器的实现类对象，并且会把指针(索引)指向集合的-1索引，通过hasNext判断集合中还有没有下一个元素，调用next方法，这时候做了两件事情：1.取出下一个元素; 2.把指针向后移动一位。

### 泛型

- **泛型**是一种未知的数据类型，当我们不知道要使用什么数据类型的时候，可以使用泛型。

  ```
  //E:未知的数据类型
  public class ArrayList<E>
  {
  	public boolean add(E e){}
  	public E get(int index){}
  }
  /*
  	在创建集合对象的时候，就会确定泛型的数据类型
  	如ArrayList<String> list = new ArrayList<String>();
  	这样上面的E都会被替换成String
  */
  ```

- **含有泛型的方法：**传递什么类型的数据，泛型就是什么数据。也可以定义含有泛型的静态方法。

  ​	如：public <E> void method(E e){ }

- **含有泛型的接口：**一种在实现接口时，确定泛型的类型；另一种是在创建对象时，确定泛型的类型。

   1. 第一种使用方式：定义接口的实现类,实现接口,指定接口的泛型

      如：public final class Scanner implements method<String>

    	2. 第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走

- **泛型通配符：**当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以使用通配符<?>表示。但是一旦使用泛型通配符后，只能使用Object类中的共性方法，集合中元素自身的方法无法使用。

  ​	不能创建对象使用，只能作为方法的参数使用。

- **泛型的上限限定：**? extends E 代表使用的泛型只能是E的子类/自身

- **泛型的下限限定：** ? super E 代表使用的泛型只能是E的父类/本身

### List接口

- 继承与Collections接口，是个有序的集合，存储元素和取出元素的顺序是一致的。有索引，包含了索引方法。允许存储重复的元素。

- List接口中带索引的方法:

  ```
  public void add(int index, E element) 将指定的元素，添加到集合中指定的位置上
  public E get(int index) 返回集合中指定位置的元素
  public E remove(int index) 移除列表中指定位置的元素，返回的是被移除的元素
  public E set(int index, E element) 用指定元素替换集合中指定位置的元素，返回的是更新前的元素
  ```

- List的实现类：

  ​	ArrayList集合，其数据结构是数组结构。多线程。元素增删慢，查询快。

  ​	LinkedList集合：其数据结构是链表结构，为双向链表。方便元素添加，删除的集合。

  ​	Vector集合：其数据结构是数组结构。单线程。


### Set接口

- 继承与Collections接口，不允许有重复的元素，没有索引，没有带索引的方法，也不能使用普通的for循环遍历。

- Set的实现类：

  ​	HashSet集合：底层是哈希表结构(查询速度快)，是一个无序集合，存储元素和取出元素的顺序有可能不一致。

  ​	LinkedHashSet集合：底层是哈希表结构，是一个有序集合，多了一条链表(记录元素的存储顺序)。

### 可变参数

- 当方法的参数列表数据类型已经确定，但是参数不确定，就可以使用可变参数。

- 在定义方法时使用，格式：修饰符 返回值类型 方法名(数据类型...变量名){}

- 可变参数的原理：可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数。传递的参数个数，可以是0个(不传递)，1，2 ... 多个。

- 可变参数的终极写法：public static void method(Object...a){}

- 如果方法有多个，那么可变参数必须写在参数列表的末尾

  如：public static void method(String b, double c, int d, int...a){}

### Map接口

- Map<K,V>将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值。

- 不同于Collecion接口(定义单列集合规范，每次只存储一个元素)，Map接口定义了双列集合的规范，每次存储一对元素(key键，value值)。K代表键的类型,V代表值的类型。

- 键唯一，值可以重复。键和值一一映射，一个键对应一个值。使用keySet()方法把多个键取出来。

- Map接口的实现类：

  ​	HashMap：底层是哈希表结构，JDK1.8之后采用数组+单向链表/红黑树，提高查询的速度。无序集合，存储元素和取出元素的顺序有可能不一致，不同步(多线程)。

  ​	LinkedHashMap：继承与HashMap，底层是哈希表+链表，集合是一个有序的集合，存储元素和取出元素的顺序一致。

  ​	Hashtable：不允许键或值为null，同步(单线程)。

- Map接口中有一个内部接口Entry，当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值的映射关系)。使用entrySet()方法把Map内部的多个Entry对象取出来。而Entry对象有方法getKey()和getValue()获取键和值。

### JDK9对添加集合元素的优化-of

- List接口，Set接口，Map接口，里面添加了一个静态方法of，可以给集合一次性添加多个元素。
- 当集合中存储的元素个数已经确定了，不在改变时使用。of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常。
- Set接口和Map接口在调用of方法时候，不能有重复元素，否则会抛出异常。

## 十、并发：

### 并发与并行

- 并发指两个或多个事件在同一个时间段内发生。
- 并行指两个或多个事件在同一时刻发生。

### 线程

- **进程：**指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程。进程也是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

- **线程：**线程是进程中的一个执行单元，负责单曲进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

- **线程调度：**

  分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间

  抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，java使用的为抢占式调度。

### Java中的多线程

- java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。java使用线程执行体来代表这段程序流。java中通过继承Thread类来创建并启动多线程的步骤如下:

  ​	1.定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。

  ​	2.创建Thread子类的实例，即创建了线程对象。

  ​	3.调用线程对象的start()方法来启动该线程。

- Thred类中的常用方法：

  ```
  public String getName() 获取当前线程的名称
  public void setName() 改变线程名称
  public void start() 导致此线程开始执行，java虚拟机调用此线程的run方法
  public void run() 此线程要执行的任务在此处定义代码
  public static void sleep(long millis) 使得当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)
  public static Thread currentThread() 返回当前正在执行的线程对象的引用
  ```

- 给线程设置名称的方法除了调用Thread类中的setName方法外。还可以创建一个带参数的构造方法，参数传递线程名称。在线程的构造函数内调用父类的带参构造方法，把线程名称传递给父类，让父类(Thread)给子线程起一个名称。

- 创建线程的另一种方法：声明实现**Runnable**接口的类，该类实现run方法。在创建Thread时作为一个参数来传递并使用start启动。

- **实现Runnable**接口创建多线程程序的好处：1.避免单继承的局限性，一个类只能继承一个类，类继承了Thread就不能继承其他类。

  2.增强了程序的扩展性，降低了程度的耦合(解耦)，实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离(解耦)。

### 匿名内部类方式实现线程创建

```
//法一：继承Thread对象的匿名内部类
new Thread(){
	@override
	public void run(){
		System.out.printLn("sf");
	}
}.start();

//法二：实现Runnable接口的匿名内部类
new Thread( new Runnable(){
	//new一个Runnable接口，通过多态实现类
	//等价于Runnable r = new RunnableImp(); 多态写法
	@override
	public void run(){
		System.out.printLn("sf");
	}
} ).start();
```

### 线程安全问题

- 多线程程序若访问了共享数据，则会产生问题。
- 解决线程安全问题：让一个线程在访问共享数据的时候，无论是否失去了cpu的执行权，让其他线程只能等待，等待当前线程的任务执行完毕，其他线程再继续执行。

### 同步

- java提供了**同步机制**来解决上述多线程并发访问一个共享资源的安全性问题。

- 完成同步操作的步骤：1.同步代码块(synchronized)。 2.同步方法。 3.锁机制。

- **同步代码块：**synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。

  格式： synchronized(同步锁){ 需要同步操作的代码 };

  其中，同步锁是一个概念，可以想象为在对象上标记了一个锁。锁对象可以是任意类型。

  多个线程对象，要使用同一把锁(最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他线程只能等着)。

- 同步技术的原理：

  ​	当线程1抢到了cpu的执行权，执行run方法，遇到synchronized代码块，这时线程1就会检查synchronized代码块是否有锁对象。*如果有，就会获取到锁对象，进入到同步中执行。*

  ​	线程2抢到了cpu的执行权，执行run方法，遇到synchronized代码块，这时线程2就会检查synchronized代码块是否有锁对象，如果没有。如果没有，线程2就会进入到阻塞状态，一直等待到线程1执行完同步中的代码，归还锁对象给同步代码块，这时线程2才能获取到锁对象进入到同步中执行。

  ​	总结：同步中的线程，没有执行完毕不会释放锁，同步外的线程没有锁进不去同步。

- **同步方法：**格式，如：public synchronized void method(){ };

  ​	对于非static静态方法，同步锁就是this。

  ​	对于static静态方法，我们使用当前方法所在类的字节码对象(类名.class)作为同步锁。

- **Lock锁：**java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作。同步代码块/同步方法具有的功能Lock机制都有，除此之外更强大，更体现面向对象。

  ​	Lock锁也被称为同步锁，加锁与释放锁方法化了，如下:

  ​	public void lock() 加同步锁

  ​	public void unlock() 释放同步锁

  ​	使用步骤：1.在成员位置创建一个ReentrantLock对象

  ​	2.在可能会出现安全问题的代码前调用Lock接口方法中的lock获取锁

  ​	3.在可能会出现安全问题的代码后调用Lock接口方法中的unlock释放锁

### 线程状态

- ```
  //线程可能处于下列线程状态之一：
  NEW 至今尚未启动的线程状态
  RUNNABLE 正在Java虚拟机中执行的线程状态
  BLOCKED 受阻塞并等待某个监视器锁的线程的线程状态
  WAITING 无限期地等待另一个线程来执行某一特点操作的线程状态
  TIMED WAITING 等待另一个线程来执行某一特点操作的线程状态
  TERMINATED 已退出的线程状态(死亡状态)
  ```

- 只有锁对象才能调用wait()和notify()方法。

  wait() 该方法使在其他线程调用此对象的notify()方法或notifyAll()方法前，导致当前线程等待。

  notify() 该方法唤醒在此对象监视器上等待的单个线程，会继续执行wait方法后的代码。

  notifyAll() 该方法会唤醒所有在等待状态的线程。

- wait(long m)方法可以传参，如果在毫秒值结束之后，还没有被notify()唤醒，就会自动醒来。

### 线程池

- 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大减低系统的效率，因为频繁创建和销毁线程需要时间。

- **线程池：**就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。

- java.util.concurrent.Executors: 线程池的工厂类，用来生成线程池。

  Executors类中的静态方法：

  static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池

  其中参数int nThreads为创建线程池中包含的线程数量。 返回值：ExecutorService接口，返回的是其实现类，我们可以使用ExecutorService接口接收(面向接口编程)。

- java.util.concurrent.ExecutorService: 线程池接口，用来从线程池中获取线程，调用start方法，执行线程任务。

  sumbit(Runnable task)提交一个Runnable 任务用于执行

  关闭/销毁线程池方法： void shutdown();

- 线程池的使用步骤：

  ​	1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生成一个指定线程数量的线程池。

  ​	2.创建一个类，实现Runnable接口，重写run方法，设置线程任务。

  ​	3.调用ExecutorService中的方法sumbit，传递线程任务(实现类)，开启线程，执行run方法。

  ​	4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行)。

## 十一、I/O:

- 