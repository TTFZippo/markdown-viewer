#       Vue笔记

创建Vue实例时: el挂载点, data数据, methods方法

### el挂载点:

- vue实例的作用范围: 
  	vue会管理el选项命中的元素及其内部的后代元素。
  	<html>与<body>无法被挂载。

### data:

- vue中用到的数据定义在data中。
  	data中可以写复杂类型的数据。
  	渲染复杂类型数据时，遵守JS语法即可。

### 本地应用(vue指令):

```
	v-text	v-html	v-on	
	v-show	v-if	v-bind
	v-for	v-model

	v-text设置标签的内容。默认写法会替换全部内容，使用 差值表达式( {{ }} )可以替换指定内容。
	v-html设置元素的innerHTML，内容中有HTML结构会被解析为标签。
	v-on为元素绑定事件，事件名不需要写on，指令可以简写为@，绑定的方法定义在methods属性中，方法内部通过this关键字可以访问定义在data中的数据。
		事件绑定的方法写成函数调用的形式，可以传入自定义参数。
		事件的后面跟上.修饰符可以对事件进行修饰，如keydown与keyon可以绑定某个按键的事件，如keydown.enter绑定按下回车键。
		修饰符stop，阻止事件冒泡。
		修饰符caputre，顺序变为事件捕获。
		修饰符self，只有触发(如点击)当前元素才能触发事件。
		修饰符prevent，阻止标签的默认行为(如a标签的跳转)。
		修饰符once，事件只能被触发一次后失效。
		修饰符passive，为scroll行为优化性能。
	v-show根据表达值的真假，切换元素的显示和隐藏(display)。
	v-if根据表达式的真假，切换元素的显示和隐藏(操作dom元素)。
	v-if可以与v-else相匹配
	v-bind设置元素的属性(比如: src, title, class)。v-bind不支持驼峰
		案例: 设置图片src时，判断vue的data中是否存在active属性，若存在，则将'http://...'赋值给图片src。简写v-bind:src   :src
		<img v-bind:src="{ http://... : active }">
		:class为元素设置CSS类名，可以为数组形式:	:class='['sf','container']'
	v-for将数据生成列表结构。 语法: v-for="item in arr" ，其中arr是vue的data中的arr数组属性。或v-for="(item,index) in arr"， 其中第二个参数index是arr数组中每个元素的索引。
	v-for还可以渲染对象。如v-for="(value,key,index)",其中value为对象属性值，key为对象属性键名，index为该对象属性的索引。
	v-model获取和设置表单元素的值(双向数据绑定)

	vue提供了一些修饰符来帮我我们方便的处理一些事件：
	.stop - 调用event.stopPropagation();
	.prevent - 调用event.preventDefault();
	.{keyCode | keyAlias} - 只当事件是从特点键触发时才触发回调
	.native - 监听组件根元素的原生事件
	.once - 只触发一次回调
```

### methods:		函数方法

### components: 	注册局部组件。			标签名:    创建后的组件名。

### vue组件化:

- 创建组件 Vue.extend()
  2.注册组件 Vue.component()，并定义组件的标签名称
  3.在Vue实例的作用范围内使用组件
  组件必须挂载到Vue实例下，否则他不生效。

- vue注册组件语法糖写法: Vue.component(sf, { template: `<div></div>` });


- 组件模板抽离方法: 
  	方法一，引入script标签:	<script type="text/x-template" id="sf"></script>，Vue.component(sf, { template: '#sf' });
  	方法二，引入template标签	<template id="sf"><div></div><template>,	Vue.component(sf, { template: '#sf' });

- 组件自己的数据存放在组件对象的data属性内，这个data属性必须是一个函数，而且这个函数返回一个对象。对象内部保存着数据。


- vue实例中，若同时有el同时有template，vue编译时候会将template中的内容替换为HTML的app


### 插槽<slot></slot>: 

- 写在模板template的html里，可被实例标签的插入内容替换
  插槽可写入默认值(没有传入则使用默认值): <slot> <button>按钮</button> </slot>
  具名插槽: <slot name="sf"></slot>, 在进行替换时，传入的只会替换匿名插槽，使用传入同名(name)的标签替换该具名插槽。
- v-slot='slotProps'获取插槽的自定义属性

### 父子组件通信，父传子props:

- props: {
  		type: string, //类型限制
    		default: 'sf', //默认值
    		required: true //是否必须传参
    	}
    	当props的type为对象或者数组时，默认值必须是一个函数。
- 子传父this.$emit();
- 父组件访问子组件的方式: $children或$refs reference(引用)
  	this.$children是一个数组类型，包含所有子组件对象。
  	$refs默认是一个空对象。
  	在某个子组件html标签中添加hef='sf'，然后使用$refs.sf可以获取该子组件。
- 子组件访问父组件的方式: $parent
  访问根的方式(Vue实例): $root

### vue组件删除：

- 子组件如果想被删除掉，一定要在父组件里

### vue组件的生命周期: 

- created(){ }
  	

- mounted(){ }

- updated(){ }

### vue脚手架：

- vue cli3初始化项目: 
  	vue create my-project
- vue ui:      vue项目管理器

### vue-router: 单页面富应用SPA(应用前端路由技术)。

	一、HTML5的histroy模式: pushState
		history.pushState({ }, "", "/sf");		//三个参数，data, title, url
		类似栈结构，弹入栈顶，通过history.back();返回。
		二、 history.replaceState({ }, "", "/sf");	//三个参数，替换URL，不刷新，不保留记录
		三、history.go(-2);		//弹出栈顶两个history，跳转。
		history.back(); = history.go(-1);
		history.forward() = history.go(1);
		四、URL的hash也就是锚点，本质是window.location的href属性。	
		location.hash = 'sf'	//页面的URL变为index.html/#sf，而页面不刷新。
	
	如果想要在vue路由中使用HTML5的history模式，在router对象中添加:
		mode: 'history';
	如果想要改变router-link激活后的类名，在router对象中添加:
		linkActiveClass: 'active';
	引入路由后使用路由: 
		<router-link to="/sf">: 该标签是一个vue-router中已经内置的组件，它会被渲染成一个<a>标签。
		<router-view>: 占位，该标签会根据当前的路径，动态渲染出不同的组件。
	在路由切换时，切换的时<router-view>挂载的组件，其他内容不会发生改变。
	<router-link>除了to属性，还有tag属性，replace，active-class属性等。
	如router-link将组件默认渲染成a标签，使用tag可以改变渲染后的标签。如tag="button"。
	如replace属性，<router-link replace>，之后点击跳转不会产生记录，即history.replace。
	如active-class属性，改变router-link激活后的类名。
	router-link点击后会有class类名的改变，通过在app.vue内可以改该样式。
	
	配置路由的默认路径: 在routes对象中配置一个映射，path配置根路径: / ，redirect是重定向，也就是我们将根据根路径重定向到/home路径下。
	如const routes = [ { path: '/', redirect: '/home' }, ]
	
	通过代码的方式修改路由 vue-router
	this.$router.push('/home');	//每个vue组件都有一个router属性。
	this.$router.replace('/home');
	
	动态路由:	希望进入/user/PacificD或/user/:id=PacificD等类似时。
	在routes对象内配置，如{ path: 'user/:userId', component: user }
	使用v-bind:to = " '/user/' + userId "
	如果是子组件想要拿到userId，可通过this.$route.params.userId
	
	路由的懒加载:
	将不同路由在打包时打包为不同JS文件，非一个。
	实现: 在routes对象中{ path: '/home', component: ()=> import('../components/Home') }
	而非import Home from '../components/Home' 之后 { path: '/home', component: Home }
	
	嵌套路由:
	步骤: 创建对应子组件，并且在路由映射中配置对应的子路由。在组件内部使用<router-view>标签。
	如想要在主页home中嵌套路由，配置routes对象:
	 { path: '/home', component: Home, children : 
		[ { path: 'news', component: News }, { path: 'about', component: About } ] }
	然后将News与About模板写入Home.vue的模板中，添加<router-view>标签。router-link的to记得补全: /home/news (router-link to="/home/news")
	
	路由传递参数:
	传递参数主要有两种类型: params和query
	params类型: 
		配置路由格式：/router/:id
		传递的方式：这种path后面跟上对应的值
		传递后形成的路径：/router/123, /router/abc
	query类型:
		配置路由格式：/router，也就是普通配置
		传递的方式：对象中使用query的key作为传递方式
		传递后形成的路径：/router?id=123, /router?id=abc
	 在<router-link :to="{ path: '/profile', query: { name: 'PacificD', age: '15' } }">
	
	route对象与router对象的区别。
	route对象是某个活跃的路由，router对象是在router->index.js文件中new的VueRouter，包含各种信息。
	
	导航守卫：
	如想要监听从哪个页面跳转到哪个页面，改变网页标题,window.document.title = 'sf';
	通过生命周期函数created(){ window.document.title = 'sf' }实现。
	推荐使用router.beforeEach(function(to,from,next){ })实现。
	router.beforeEach()路由跳转前的回调(前置首位guard)。
	router.afterEach()路由跳转后的回调(后置钩子hook)，不需要next函数。
	
	keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，避免被重新渲染。	
	使组件在切换时不被重新创建与销毁，提升性能。
	他有两个属性: include，exclude 字符串或正则表达式，匹配的组件都会被/不会被缓存。
### vuex：

	Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
		Vuex使用单一状态数来管理应用层级的全部状态，多个store管理和维护都会变得困难。
		可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面，然后将这个对象放在顶层的vue实例中，让其他组件可以使用。多个组件就可以共享这个对象的所有变量属性了。
		state, getters, actions, mutations, modules。默认在mutations中改变共享数据，异步操作放入actions中。调用mutations中的方法时，默认传入state对象。
		在app实例或子组件中，调用this.$store.commit('sf'); 其中sf为store内mutations或actions中的函数。
		state用于存储数据与状态。	 getters，用于做某些计算。(getters默认是不能传递参数的，如果希望传递参数，那么只能让getters本身返回另一个函数)。
		
		mutations: 
			vuex的store的状态更新唯一方式。 
			mutations中可以有两部分：字符串的事件类型，回调函数，该回调函数的第一个参数就是state。
			通过mutations更新vuex的store的状态，通过提交this.$store.commit('sf'); 
			mutations通过this.$store.commit('sf', 'count');接收参数。该参数(count)称为mutations的载荷(payload)。
			Vue提供一种特殊的提交方式: this.$store.commit({ type: 'sf', count }); 这种方式提交的count是一个对象(载荷)mutations响应规则:
	vuex的store中的state是响应式的，当state中的数据发生改变时，vue组件会自动更新。
	这就要求我们必须遵守一些vuex对应的规则：
		提前在store中初始化所需的属性、数据。
		当给state中的对象添加新属性时(响应式)，使用以下方式：
		一、使用Vue.set(obj, 'newProp', 123)
		二、用新对象给旧对象重新赋值。
		给state对象删除属性时，使用Vue.delete(obj, key, value)。
	
	mutations同步函数：
	vuex要求我们mutations中的方法必须是同步方法，主要原因是当我们使用devtool时，可以使用devtools帮助我们捕捉mutations快照。如果是异步操作，devtools将不能很好的追踪这个操作什么时候被完成。 解决方案：将此异步操作放入actions中来替代mutations。
	
	actions：
	actions中的函数有个默认参数：context，类似store对象。
	想要异步操作修改state，通过actions中的异步操作处理mutations后修改state。
	在actions中，通过context.commit('sf'); 在mutations中，通过this.$store.dispatch('update');
	
	module：
	vuex允许将store分割成模块module，而每个模块拥有自己的state, mutation, action, getters，如分割a: {}, b: {}对象。
### vue打包: 

- npm run build
  	打包后打开index.html会显示空白且报错，原因是根路径错误。
  	解决方案：	不要在路由中使用mode: 'history'，在项目根目录下新建vue.config.js文件，输入
  	module.exports = { publicPath: './' }



# Vue常见问题

### 改变插件组件的样式/改变scoped的样式:

- 在vue中，我们为了避免父组件的样式影响到子组件的样式，会在style中加<style scoped>，这样父组件中如果有跟子组件相同的class名称或者使用选择器的时候，就不会影响到子组件的样式。
- 但是这样也存在着一个问题，比如你使用了别人的组件或者自己开发一个组件，有时候你修改一处就可能影响到别的地方，这个时候要么你不用别人的组件，自己重新封装一个，但很多时候是不太现实的，所以就需要有一个方法或者方式，既不影响到别的地方，又能修改子组件在当前的样式。
- 解决方案：在CSS选择器内加入/deep/ (深度选择器) 或加 >>>

### Vue中动态绑定元素类名:

- 对象写法:	v-bind:class='{ ' nav-active' : index === currentIndex }'

  判断条件：当index全等于currentIndex时赋予该元素类名'nav-active'

- 数组写法：v-bind:class='[ 'nav-item', index === currentIndex ? 'nav-active' : ' ' ]'

### vue2.X中为响应式对象数据添加属性：

- vue2.x无法直接为挂载的响应式对象数据添加属性，需要使用this.$set(object, key ,value)来添加。
- 而vue3.x可以直接添加。

# Vue3.X笔记

### Vue2.X生命周期：

![Vue2.X生命周期](https://www.hualigs.cn/image/60b0a06a69147.jpg)

![vue2与vue3生命周期对比](https://www.hualigs.cn/image/60b0a16880917.jpg)

vue3中的生命周期函数写在setup()函数内。使用生命周期函数前需要import { } from 'vue'来导入。

vue3的props实现父子间的通信，在子组件需要将props传入setup()。





### 响应式数据：

- 在vue3中，数据写在setup(){ }内，后return，想要将简单数据变成动态响应数据需要使用ref()包裹。
- ref内的数据在获取使用时候，需要使用value获取。如let num = ref(1); 之后使用需num.value = 2;
  
- reactive方法是让复杂类型数据变成响应式，不需要通过.value获取，可直接操作，数组需用push。
- torefs将已经用reactive包裹的响应式复杂类型数据解析为简单数据类型，将该复杂类型数据对象的每个键值对变成ref包裹的简单数据类型。

### Vue3使用Watch侦听器：

- import {watch}后 使用watch函数。
- watch的参数：第一个参数为要观察的数据，第二个对象为回调函数。该回调函数接收参数，第一个参数为watch后的新值，第二个参数为watch前的久值。
- watch侦听的数据只能为ref包裹的数据，无法侦听reactive数据。

### Vue3使用computed计算属性：

- import { computed }后，使用computed函数

- computed接收一个getter函数，做计算处理

  